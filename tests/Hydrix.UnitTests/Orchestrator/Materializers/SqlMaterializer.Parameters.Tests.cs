using Hydrix.Orchestrator.Materializers;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using Xunit;

namespace Hydrix.UnitTests.Orchestrator.Materializers
{
    /// <summary>
    /// Contains unit tests for the SqlMaterializer class, verifying parameter handling and formatting behaviors for SQL
    /// command construction.
    /// </summary>
    /// <remarks>These tests cover scenarios such as scalar and enumerable parameter binding, parameter name
    /// formatting, and value formatting for various data types. The class uses mock implementations of IDbCommand and
    /// related interfaces to isolate and validate SqlMaterializer logic without requiring a real database
    /// connection.</remarks>
    public partial class SqlMaterializerTests
    {
        /// <summary>
        /// Provides test access to internal parameter-related functionality of the SqlMaterializer class.
        /// </summary>
        /// <remarks>This class is intended for testing scenarios where direct invocation of internal
        /// methods of SqlMaterializer is required. It exposes static and instance methods that allow tests to interact
        /// with parameter handling logic, such as adding parameters to commands or formatting parameter values. This
        /// class should not be used in production code.</remarks>
        private class TestSqlMaterializerParameter :
            SqlMaterializer
        {
            /// <summary>
            /// Initializes a new instance of the TestSqlMaterializerParameter class with the specified parameter
            /// prefix.
            /// </summary>
            /// <remarks>Use this constructor to customize the prefix used for SQL parameters when
            /// materializing queries. The prefix is applied to all parameters generated by this instance.</remarks>
            /// <param name="prefix">The string to use as the prefix for SQL parameters. Defaults to "@" if not specified.</param>
            public TestSqlMaterializerParameter(string prefix = "@") :
                base(null, parameterPrefix: prefix)
            {
                typeof(SqlMaterializer)
                    .GetField("_parameterPrefix", BindingFlags.Instance | BindingFlags.NonPublic)
                    ?.SetValue(this, prefix);
            }

            /// <summary>
            /// Determines whether the specified value is considered an enumerable parameter for SQL materialization
            /// purposes.
            /// </summary>
            /// <remarks>This method is intended for advanced scenarios where it is necessary to check
            /// if a value will be treated as an enumerable parameter by the SQL materializer. The criteria for what
            /// constitutes an enumerable parameter are defined internally and may change in future versions.</remarks>
            /// <param name="value">The value to evaluate as a potential enumerable parameter. Can be any object, including null.</param>
            /// <returns>true if the value is recognized as an enumerable parameter; otherwise, false.</returns>
            public static bool CallIsEnumerableParameter(object value) =>
                typeof(SqlMaterializer)
                    .GetMethod("IsEnumerableParameter", BindingFlags.Static | BindingFlags.NonPublic)
                    .Invoke(null, new[] { value }) is bool b && b;

            /// <summary>
            /// Adds a scalar parameter with the specified name and value to the given database command.
            /// </summary>
            /// <param name="cmd">The database command to which the parameter will be added. Must not be null.</param>
            /// <param name="name">The name of the parameter to add. Cannot be null or empty.</param>
            /// <param name="value">The value to assign to the parameter. May be null to represent a database null value.</param>
            public void CallAddScalarParameter(IDbCommand cmd, string name, object value) =>
                typeof(SqlMaterializer)
                    .GetMethod("AddScalarParameter", BindingFlags.Instance | BindingFlags.NonPublic)
                    .Invoke(this, new object[] { cmd, name, value });

            /// <summary>
            /// Expands an enumerable parameter for use in a database command, enabling the command to handle a
            /// collection of values as a single parameter.
            /// </summary>
            /// <remarks>This method is typically used to support SQL 'IN' clauses or similar
            /// scenarios where a parameterized query needs to accept multiple values. The command object is modified to
            /// include the expanded parameters as required by the underlying database provider.</remarks>
            /// <param name="cmd">The database command to which the enumerable parameter will be added. Must not be null.</param>
            /// <param name="name">The name of the parameter to expand within the command. Cannot be null or empty.</param>
            /// <param name="values">The collection of values to be expanded into the parameter. Can be any enumerable; must not be null.</param>
            public void CallExpandEnumerableParameter(IDbCommand cmd, string name, IEnumerable values) =>
                typeof(SqlMaterializer)
                    .GetMethod("ExpandEnumerableParameter", BindingFlags.Instance | BindingFlags.NonPublic)
                    .Invoke(this, new object[] { cmd, name, values });

            /// <summary>
            /// Adds a parameter with the specified name and value to the given database command.
            /// </summary>
            /// <param name="cmd">The database command to which the parameter will be added. Cannot be null.</param>
            /// <param name="name">The name of the parameter to add. Cannot be null or empty.</param>
            /// <param name="value">The value to assign to the parameter. May be null to represent a database null value.</param>
            public void CallAddParameter(IDbCommand cmd, string name, object value) =>
                typeof(SqlMaterializer)
                    .GetMethod("AddParameter", BindingFlags.Instance | BindingFlags.NonPublic)
                    .Invoke(this, new object[] { cmd, name, value });

            /// <summary>
            /// Binds the specified parameters object to the given database command by mapping its properties to command
            /// parameters.
            /// </summary>
            /// <remarks>This method uses reflection to map the properties of the parameters object to
            /// the parameters of the database command. Property names should match the expected parameter names of the
            /// command. If a property value is null, the corresponding parameter will be set to DBNull.Value.</remarks>
            /// <param name="cmd">The database command to which parameters will be bound. Must not be null.</param>
            /// <param name="parameters">An object whose public properties represent the parameter names and values to bind to the command. Can
            /// be null if no parameters are required.</param>
            public void CallBindParametersFromObject(IDbCommand cmd, object parameters) =>
                typeof(SqlMaterializer)
                    .GetMethod("BindParametersFromObject", BindingFlags.Instance | BindingFlags.NonPublic)
                    .Invoke(this, new object[] { cmd, parameters });

            /// <summary>
            /// Formats the specified value as a string suitable for use as a SQL parameter.
            /// </summary>
            /// <remarks>This method is intended for advanced scenarios where direct access to the
            /// internal SQL parameter formatting logic is required. It uses reflection to invoke a non-public method
            /// and may be subject to change in future versions. Use with caution.</remarks>
            /// <param name="value">The value to format for SQL parameterization. Can be null.</param>
            /// <returns>A string representation of the value formatted for SQL parameter usage, or null if the value cannot be
            /// formatted.</returns>
            public static string CallFormatParameterValue(object value) =>
                typeof(SqlMaterializer)
                    .GetMethod("FormatParameterValue", BindingFlags.Static | BindingFlags.NonPublic)
                    .Invoke(null, new[] { value }) as string;
        }

        /// <summary>
        /// Represents a parameter to a command object, such as a SQL query or stored procedure, for use with a mock
        /// database implementation.
        /// </summary>
        /// <remarks>This class implements the IDbDataParameter interface to provide parameter information
        /// for database commands in testing or mock scenarios. It is not intended for use with actual database
        /// connections.</remarks>
        private class MockDbParameter :
            IDbDataParameter
        {
            /// <summary>
            /// Gets or sets the name of the parameter associated with this instance.
            /// </summary>
            public string ParameterName { get; set; }

            /// <summary>
            /// Gets or sets the value associated with this instance.
            /// </summary>
            public object Value { get; set; }

            /// <summary>
            /// Gets or sets the database type of the parameter.
            /// </summary>
            public DbType DbType { get; set; }

            /// <summary>
            /// Gets or sets the direction of the parameter within a command or stored procedure.
            /// </summary>
            /// <remarks>Use this property to specify whether the parameter is an input, output,
            /// bidirectional, or a return value parameter. The default is typically Input. Setting the correct
            /// direction is important for commands that expect output or return values from stored
            /// procedures.</remarks>
            public ParameterDirection Direction { get; set; }

            /// <summary>
            /// Gets a value indicating whether the current type allows null values.
            /// </summary>
            public bool IsNullable => false;

            /// <summary>
            /// Gets or sets the name of the source column mapped to the data field.
            /// </summary>
            public string SourceColumn { get; set; }

            /// <summary>
            /// Gets or sets the version of data in a DataRow to use when loading parameter values.
            /// </summary>
            /// <remarks>This property determines which version of the DataRow's data is used when
            /// retrieving parameter values, such as Original, Current, or Proposed. It is commonly used in data access
            /// scenarios where parameters are populated from DataRow objects, for example, during database updates or
            /// inserts.</remarks>
            public DataRowVersion SourceVersion { get; set; }

            /// <summary>
            /// Gets or sets the number of significant digits used for numeric values.
            /// </summary>
            public byte Precision { get; set; }

            /// <summary>
            /// Gets or sets the number of decimal places to which a value is scaled.
            /// </summary>
            public byte Scale { get; set; }

            /// <summary>
            /// Gets or sets the size value.
            /// </summary>
            public int Size { get; set; }
        }

        /// <summary>
        /// Represents a collection of database parameters for a command, supporting access by parameter name and index.
        /// </summary>
        /// <remarks>This collection is intended for use with mock or test implementations of database
        /// commands that require parameter management. It implements both IList and IDataParameterCollection
        /// interfaces, allowing parameters to be added, removed, or accessed by name or ordinal position. The
        /// collection is not thread-safe.</remarks>
        private class MockDbParameterCollection :
            List<IDbDataParameter>, IDataParameterCollection
        {
            /// <summary>
            /// Gets or sets the parameter with the specified name.
            /// </summary>
            /// <param name="parameterName">The name of the parameter to retrieve or set. The comparison is typically case-sensitive. Cannot be
            /// null.</param>
            /// <returns>The parameter object associated with the specified name, or null if no parameter with that name exists.</returns>
            public object this[string parameterName]
            {
                get => this.FirstOrDefault(p => p.ParameterName == parameterName);
                set { }
            }

            /// <summary>
            /// Adds an object to the collection as a parameter and returns the index at which the parameter was added.
            /// </summary>
            /// <param name="value">The parameter object to add to the collection. Must implement the IDbDataParameter interface. Cannot be
            /// null.</param>
            /// <returns>The zero-based index at which the parameter was added to the collection.</returns>
            public int Add(object value)
            {
                base.Add((IDbDataParameter)value);
                return Count - 1;
            }

            /// <summary>
            /// Determines whether a parameter with the specified name exists in the collection.
            /// </summary>
            /// <param name="parameterName">The name of the parameter to locate. The comparison is case-sensitive.</param>
            /// <returns>true if a parameter with the specified name exists in the collection; otherwise, false.</returns>
            public bool Contains(string parameterName)
                => this.Any(p => p.ParameterName == parameterName);

            /// <summary>
            /// Returns the zero-based index of the parameter with the specified name.
            /// </summary>
            /// <param name="parameterName">The name of the parameter to locate. The comparison is case-sensitive.</param>
            /// <returns>The zero-based index of the parameter if found; otherwise, -1.</returns>
            public int IndexOf(string parameterName)
                => this.FindIndex(p => p.ParameterName == parameterName);

            /// <summary>
            /// Removes the parameter with the specified name from the collection.
            /// </summary>
            /// <remarks>If the parameter with the specified name does not exist in the collection, no
            /// action is taken.</remarks>
            /// <param name="parameterName">The name of the parameter to remove. The comparison is typically case-sensitive, depending on the
            /// implementation.</param>
            public void RemoveAt(string parameterName)
            {
                var idx = IndexOf(parameterName);
                if (idx >= 0) RemoveAt(idx);
            }

            /// <summary>
            /// Determines whether the collection contains a parameter with the specified value.
            /// </summary>
            /// <param name="value">The parameter to locate in the collection. Must be an object that implements the IDbDataParameter
            /// interface.</param>
            /// <returns>true if the parameter is found in the collection; otherwise, false.</returns>
            public bool Contains(object value)
                => base.Contains((IDbDataParameter)value);

            /// <summary>
            /// Returns the zero-based index of the first occurrence of the specified parameter in the collection.
            /// </summary>
            /// <param name="value">The parameter to locate in the collection. Must be an object that implements the IDbDataParameter
            /// interface.</param>
            /// <returns>The zero-based index of the first occurrence of the specified parameter in the collection; otherwise, -1
            /// if the parameter is not found.</returns>
            public int IndexOf(object value)
                => base.IndexOf((IDbDataParameter)value);

            /// <summary>
            /// Inserts an object into the collection at the specified index.
            /// </summary>
            /// <param name="index">The zero-based index at which the value should be inserted. Must be greater than or equal to 0 and less
            /// than or equal to the number of items in the collection.</param>
            /// <param name="value">The object to insert into the collection. Must implement the IDbDataParameter interface and cannot be
            /// null.</param>
            public void Insert(int index, object value)
                => base.Insert(index, (IDbDataParameter)value);

            /// <summary>
            /// Removes the specified parameter from the collection.
            /// </summary>
            /// <remarks>If the specified object is not found in the collection, no action is taken.
            /// The method expects the parameter to be of type <see cref="IDbDataParameter"/>; passing an object of a
            /// different type will result in an exception.</remarks>
            /// <param name="value">The parameter object to remove from the collection. Must be an instance of <see
            /// cref="IDbDataParameter"/>.</param>
            public void Remove(object value)
                => base.Remove((IDbDataParameter)value);

            /// <summary>
            /// Copies the elements of the collection to a specified array, starting at a particular index.
            /// </summary>
            /// <param name="array">The one-dimensional array that is the destination of the elements copied from the collection. The array
            /// must have zero-based indexing.</param>
            /// <param name="index">The zero-based index in the destination array at which copying begins.</param>
            public void CopyTo(Array array, int index)
                => ((ICollection)this).CopyTo(array, index);

            /// <summary>
            /// Gets a value indicating whether access to the collection is synchronized (thread safe).
            /// </summary>
            /// <remarks>This property always returns <see langword="false"/>. Access to the
            /// collection is not synchronized; callers must implement their own synchronization if thread safety is
            /// required.</remarks>
            public bool IsSynchronized => false;

            /// <summary>
            /// Gets an object that can be used to synchronize access to the collection.
            /// </summary>
            /// <remarks>Use this object to lock the collection during multithreaded operations to
            /// ensure thread safety. Synchronizing access using the SyncRoot property is necessary when multiple
            /// threads might access the collection concurrently.</remarks>
            public object SyncRoot => this;

            /// <summary>
            /// Gets a value indicating whether the collection has a fixed size.
            /// </summary>
            public bool IsFixedSize => false;

            /// <summary>
            /// Gets a value indicating whether the collection is read-only.
            /// </summary>
            public bool IsReadOnly => false;
        }

        /// <summary>
        /// Provides a mock implementation of the <see cref="IDbCommand"/> interface for use in testing database-related
        /// code without requiring a real database connection.
        /// </summary>
        /// <remarks>This class is intended for use in unit tests or scenarios where a lightweight,
        /// non-functional database command object is needed. All methods and properties are implemented with minimal or
        /// no behavior, and do not interact with an actual database. Return values are typically default values or
        /// null, and no exceptions are thrown for unsupported operations.</remarks>
        private class MockDbCommand : IDbCommand
        {
            /// <summary>
            /// Gets or sets the SQL statement or command to execute against the data source.
            /// </summary>
            public string CommandText { get; set; }

            /// <summary>
            /// Gets the collection of parameters associated with the command.
            /// </summary>
            /// <remarks>Use this collection to add, remove, or access parameters that are sent to the
            /// data source with the command. The collection is empty if no parameters have been added.</remarks>
            public IDataParameterCollection Parameters { get; } = new MockDbParameterCollection();

            /// <summary>
            /// Creates a new instance of a parameter object for use with a database command.
            /// </summary>
            /// <returns>An <see cref="IDbDataParameter"/> instance that can be used to represent a parameter in a database
            /// command.</returns>
            public IDbDataParameter CreateParameter()
                => new MockDbParameter();

            /// <summary>
            /// Gets or sets the wait time, in seconds, before terminating an attempt to execute a command and
            /// generating an error.
            /// </summary>
            /// <remarks>A value of 0 indicates no limit, and the command will wait indefinitely.
            /// Setting this property to a negative value will throw an exception. The default value is typically 30
            /// seconds, but may vary depending on the provider.</remarks>
            public int CommandTimeout { get; set; }

            /// <summary>
            /// Gets or sets a value indicating how the command string is interpreted by the data provider.
            /// </summary>
            /// <remarks>Set this property to specify whether the command text represents a raw SQL
            /// statement, a stored procedure, or a table name. The default is typically CommandType.Text, which treats
            /// the command as a SQL query. Changing this property may affect how parameters are handled and how the
            /// command is executed by the underlying data provider.</remarks>
            public CommandType CommandType { get; set; }

            /// <summary>
            /// Gets or sets the database connection used to execute commands.
            /// </summary>
            public IDbConnection Connection { get; set; }

            /// <summary>
            /// Executes the command and returns a data reader for reading the results.
            /// </summary>
            /// <returns>An <see cref="IDataReader"/> object that can be used to read the results of the command. The caller is
            /// responsible for closing the data reader when finished.</returns>
            public IDataReader ExecuteReader()
                => null;

            /// <summary>
            /// Executes the command and returns a data reader for reading the results, using the specified command
            /// behavior.
            /// </summary>
            /// <param name="behavior">A bitwise combination of CommandBehavior values that determines how the command results are read and how
            /// the connection is managed.</param>
            /// <returns>An IDataReader object for reading the results of the command. The caller is responsible for closing the
            /// data reader when finished.</returns>
            public IDataReader ExecuteReader(CommandBehavior behavior)
                => null;

            /// <summary>
            /// Executes the query and returns the first column of the first row in the result set.
            /// </summary>
            /// <returns>An object representing the value of the first column of the first row in the result set, or null if the
            /// result set is empty.</returns>
            public object ExecuteScalar()
                => null;

            /// <summary>
            /// Requests cancellation of the current operation, if one is in progress.
            /// </summary>
            /// <remarks>Calling this method signals that the ongoing operation should be canceled as
            /// soon as possible. The exact timing and effect of cancellation depend on the implementation. If no
            /// operation is in progress, this method has no effect.</remarks>
            public void Cancel()
            { }

            /// <summary>
            /// Gets an array containing all parameters as <see cref="IDbDataParameter"/> objects.
            /// </summary>
            public IDbDataParameter[] ParametersArray
                => Parameters.Cast<IDbDataParameter>().ToArray();

            /// <summary>
            /// Gets or sets the database transaction to be used for executing commands.
            /// </summary>
            /// <remarks>Set this property to associate database operations with a specific
            /// transaction. If not set, commands will execute outside of any explicit transaction context. The caller
            /// is responsible for managing the lifetime and disposal of the transaction object.</remarks>
            public IDbTransaction Transaction { get; set; }

            /// <summary>
            /// Gets or sets a value that determines how command results are applied to the DataRow when used with an
            /// update operation.
            /// </summary>
            /// <remarks>Use this property to control whether output parameters, first returned rows,
            /// or both are mapped back to the DataRow during an update. The default value and supported options may
            /// vary depending on the specific data provider implementation.</remarks>
            public UpdateRowSource UpdatedRowSource { get; set; }

            /// <summary>
            /// Releases all resources used by the current instance.
            /// </summary>
            /// <remarks>Call this method when you are finished using the object to free unmanaged
            /// resources and perform other cleanup operations. After calling Dispose, the object should not be used
            /// further.</remarks>
            public void Dispose()
            { }

            /// <summary>
            /// Executes a SQL statement against the connection and returns the number of rows affected.
            /// </summary>
            /// <returns>The number of rows affected by the SQL statement. Returns -1 for statements that do not affect rows,
            /// such as DDL statements.</returns>
            public int ExecuteNonQuery() => 0;

            /// <summary>
            /// Performs any necessary setup or initialization required before executing operations on this instance.
            /// </summary>
            public void Prepare()
            { }
        }

        /// <summary>
        /// Verifies that the IsEnumerableParameter method correctly determines whether the specified value is
        /// considered an enumerable parameter.
        /// </summary>
        /// <param name="value">The value to test for enumerable parameter status. Can be null or any object.</param>
        /// <param name="expected">The expected result indicating whether the value should be recognized as an enumerable parameter.</param>
        [Theory]
        [InlineData(null, false)]
        [InlineData("string", false)]
        [InlineData(new byte[] { 1, 2 }, false)]
        [InlineData(new int[] { 1, 2 }, true)]
        [InlineData(new string[] { "a", "b" }, true)]
        [InlineData(42, false)]
        public void IsEnumerableParameter_Works(object value, bool expected)
        {
            Assert.Equal(expected, TestSqlMaterializerParameter.CallIsEnumerableParameter(value));
        }

        /// <summary>
        /// Verifies that the AddScalarParameter method adds a parameter with the correct name and value to the command.
        /// </summary>
        /// <remarks>This unit test ensures that when AddScalarParameter is called, the resulting
        /// parameter in the command has the expected name and value. It is intended to validate correct parameter
        /// handling in the TestSqlMaterializerParameter class.</remarks>
        [Fact]
        public void AddScalarParameter_AddsParameterWithCorrectNameAndValue()
        {
            var mat = new TestSqlMaterializerParameter("@");
            var cmd = new MockDbCommand();
            mat.CallAddScalarParameter(cmd, "foo", 123);
            var param = cmd.Parameters[0] as IDbDataParameter;
            Assert.Equal("@foo", param.ParameterName);
            Assert.Equal(123, param.Value);
        }

        /// <summary>
        /// Verifies that adding a scalar parameter with a null value results in the parameter's value being set to
        /// DBNull.Value.
        /// </summary>
        /// <remarks>This test ensures that the AddScalarParameter method correctly handles null values by
        /// converting them to DBNull.Value when adding parameters to a database command. This behavior is important for
        /// compatibility with ADO.NET, which requires DBNull.Value to represent database nulls.</remarks>
        [Fact]
        public void AddScalarParameter_NullValue_UsesDBNull()
        {
            var mat = new TestSqlMaterializerParameter("@");
            var cmd = new MockDbCommand();
            mat.CallAddScalarParameter(cmd, "bar", null);
            var param = cmd.Parameters[0] as IDbDataParameter;
            Assert.Equal(DBNull.Value, param.Value);
        }

        /// <summary>
        /// Verifies that expanding an enumerable parameter in a SQL command adds individual parameters for each value
        /// and updates the command text accordingly.
        /// </summary>
        /// <remarks>This test ensures that when an enumerable parameter is expanded, the command text
        /// replaces the original parameter placeholder with unique parameter names for each value in the collection,
        /// and that the corresponding parameters are added to the command. This behavior is important for supporting
        /// SQL 'IN' clauses with parameterized queries.</remarks>
        [Fact]
        public void ExpandEnumerableParameter_AddsParametersAndUpdatesCommandText()
        {
            var mat = new TestSqlMaterializerParameter("@");
            var cmd = new MockDbCommand { CommandText = "SELECT * FROM T WHERE id IN (@ids)" };
            mat.CallExpandEnumerableParameter(cmd, "ids", new[] { 1, 2, 3 });
            Assert.Equal(3, cmd.Parameters.Count);
            Assert.All(cmd.Parameters.Cast<IDbDataParameter>(), p => Assert.StartsWith("@ids_", p.ParameterName));
            Assert.Contains("@ids_0", cmd.CommandText);
            Assert.Contains("@ids_1", cmd.CommandText);
            Assert.Contains("@ids_2", cmd.CommandText);
            Assert.DoesNotContain("@ids)", cmd.CommandText);
        }

        /// <summary>
        /// Verifies that adding a scalar parameter using the AddParameter method results in a single parameter being
        /// added to the command with the correct name and value.
        /// </summary>
        /// <remarks>This unit test ensures that when a scalar value is provided to AddParameter, the
        /// parameter is named with the expected prefix and assigned the correct value in the command's parameter
        /// collection.</remarks>
        [Fact]
        public void AddParameter_Scalar_AddsSingleParameter()
        {
            var mat = new TestSqlMaterializerParameter("@");
            var cmd = new MockDbCommand();
            mat.CallAddParameter(cmd, "foo", 42);
            Assert.Single(cmd.Parameters);
            Assert.Equal("@foo", ((IDbDataParameter)cmd.Parameters[0]).ParameterName);
            Assert.Equal(42, ((IDbDataParameter)cmd.Parameters[0]).Value);
        }

        /// <summary>
        /// Verifies that adding an enumerable parameter to a SQL command expands the parameter into multiple individual
        /// parameters in the command text and parameter collection.
        /// </summary>
        /// <remarks>This test ensures that when an enumerable value is provided as a parameter, each
        /// element is assigned a unique parameter name and added to the command, allowing for correct SQL 'IN' clause
        /// expansion.</remarks>
        [Fact]
        public void AddParameter_Enumerable_ExpandsParameters()
        {
            var mat = new TestSqlMaterializerParameter("@");
            var cmd = new MockDbCommand { CommandText = "WHERE x IN (@x)" };
            mat.CallAddParameter(cmd, "x", new[] { 7, 8 });
            Assert.Equal(2, cmd.Parameters.Count);
            Assert.Contains("@x_0", cmd.CommandText);
            Assert.Contains("@x_1", cmd.CommandText);
        }

        /// <summary>
        /// Verifies that all public properties of an object are correctly bound as parameters to a database command.
        /// </summary>
        /// <remarks>This test ensures that each property of the provided object results in a
        /// corresponding parameter on the command, with the correct parameter name and value. It validates the behavior
        /// of the parameter binding logic when handling objects with multiple properties.</remarks>
        [Fact]
        public void BindParametersFromObject_BindsAllProperties()
        {
            var mat = new TestSqlMaterializerParameter("@");
            var cmd = new MockDbCommand();
            var obj = new { A = 1, B = "b" };
            mat.CallBindParametersFromObject(cmd, obj);
            Assert.Equal(2, cmd.Parameters.Count);
            Assert.Contains(cmd.Parameters.Cast<IDbDataParameter>(), p => p.ParameterName == "@A" && (int)p.Value == 1);
            Assert.Contains(cmd.Parameters.Cast<IDbDataParameter>(), p => p.ParameterName == "@B" && (string)p.Value == "b");
        }

        /// <summary>
        /// Verifies that binding parameters from an object with an enumerable property expands the property into
        /// individual parameters in the command text and parameter collection.
        /// </summary>
        /// <remarks>This test ensures that when an object containing an enumerable property is used to
        /// bind parameters to a database command, each element in the enumerable is assigned a separate parameter, and
        /// the command text is updated to reference each expanded parameter.</remarks>
        [Fact]
        public void BindParametersFromObject_ExpandsEnumerableProperty()
        {
            var mat = new TestSqlMaterializerParameter("@");
            var cmd = new MockDbCommand { CommandText = "IN (@Ids)" };
            var obj = new { Ids = new[] { 1, 2 } };
            mat.CallBindParametersFromObject(cmd, obj);
            Assert.Equal(2, cmd.Parameters.Count);
            Assert.Contains("@Ids_0", cmd.CommandText);
            Assert.Contains("@Ids_1", cmd.CommandText);
        }

        /// <summary>
        /// Verifies that the parameter formatting logic correctly handles common data types and produces the expected
        /// string representations.
        /// </summary>
        /// <remarks>This test covers typical cases for parameter formatting, including null values,
        /// strings, numeric types, booleans, and date strings. It ensures that the formatting method produces
        /// consistent and correct output for these common scenarios.</remarks>
        /// <param name="value">The input value to be formatted. Can be null or an instance of a supported type such as string, integer,
        /// boolean, or date string.</param>
        /// <param name="expected">The expected string representation of the formatted parameter value.</param>
        [Theory]
        [InlineData(null, "NULL")]
        [InlineData("abc", "'abc'")]
        [InlineData(123, "123")]
        [InlineData(true, "1")]
        [InlineData(false, "0")]
        [InlineData("2020-01-01", "'2020-01-01'")]
        public void FormatParameterValue_HandlesCommonTypes(object value, string expected)
        {
            if (value is string s && DateTime.TryParse(s, out var dt))
                Assert.Equal($"'{dt:yyyy-MM-dd HH:mm:ss.fff}'", TestSqlMaterializerParameter.CallFormatParameterValue(dt));
            else
                Assert.Equal(expected, TestSqlMaterializerParameter.CallFormatParameterValue(value));
        }

        /// <summary>
        /// Tests that the parameter value formatting method correctly formats a Guid value as a string enclosed in
        /// single quotes.
        /// </summary>
        [Fact]
        public void FormatParameterValue_Guid()
        {
            var guid = Guid.NewGuid();
            Assert.Equal($"'{guid}'", TestSqlMaterializerParameter.CallFormatParameterValue(guid));
        }

        /// <summary>
        /// Verifies that formatting a parameter value of type DBNull returns the string "NULL".
        /// </summary>
        [Fact]
        public void FormatParameterValue_DBNull()
        {
            Assert.Equal("NULL", TestSqlMaterializerParameter.CallFormatParameterValue(DBNull.Value));
        }
    }
}